'''
@File: mkalman_filter.py
@Software: PyCharm
@Author: Yanjie Wen(MitSui)
@Institution: CSU&BUCEA
@E-mail: obitowen@csu.edu.cn
@Time: 6月 29, 2025
@HomePage: https://github.com/YanJieWen
'''


from copy import deepcopy
from math import log,exp,sqrt
import sys
import numpy as np
import scipy.linalg

from filterpy.stats import logpdf
from filterpy.common import reshape_z,pretty_str

'''
References:
https://github.com/NirAharon/BoT-SORT/blob/main/tracker/kalman_filter.py
https://github.com/noahcao/OC_SORT/blob/master/trackers/ocsort_tracker/kalmanfilter.py
'''


class MesKalmanFilterNew(object):
    def __init__(self,dimx,dimz,dimu=0):
        if dimx<1:
            raise ValueError('dimx must be 1 or greater')
        if dimz<1:
            raise ValueError('dimz must be 1 or greater')
        self.dim_x = dimx
        self.dim_z = dimz
        self.dim_u = dimu
        #Predict parameters
        self.x = np.zeros((dimx,1)) #kf state-->[x,y,w,h,x',y',w',h']
        self.P = np.eye(dimx) #covariance
        self.Q = np.eye(dimx) #noise matrix
        self.B = None #control transition matrix
        self.F = np.eye(dimx) #state transition matrix
        #these will be a copy of x,P, if predict() is called
        self.x_prior = self.x.copy()
        self.P_prior = self.P.copy()

        #Update parameters-->kalman gain and residual are created in update()
        #save them we can check them anywhere
        self.R = np.eye(dimz) #observed noise
        self.H = np.zeros((dimz,dimx)) #observed function
        self.z = np.array([[None]*self.dim_z]).T #measurement-->[x,y,w,h]
        self.K = np.zeros((dimx,dimz)) #kalman gain
        self.y = np.zeros((dimz,1)) #residual
        self.S = np.zeros((dimz,dimz)) #system covariance
        self.SI = np.zeros((dimz, dimz)) #inverse of S
        # self.SI = np.zeros((dimz,dimz)) #inverse system covariance
        self._I = np.eye(dimx)
        #these will be a copy of x,P if update() is called
        self.x_post = self.x.copy()
        self.P_post = self.P.copy()

        #only if requested via property
        self._log_likehood = log(sys.float_info.min)
        self._likelihood = sys.float_info.min
        self._mahalanobis = None

        #keep all historical observations
        self.history_obs = []
        self.attr_saved = None
        self.observed = False
        self.last_obs = None


    def predict(self,u=None,B=None,F=None,Q=None):
        '''
        using kalman filter to predict next step state according to
        prior state. x and P are updated and saved.
        Args:
            u: np.array,default 0
            B: np.array,(dimx,dimu),default None
            F: np.array (dimx,dimx)
            Q: np.array (dimx,dimx)
        '''
        if B is None:
            B = self.B
        if F is None:
            F = self.F
        if Q is None:
            Q = self.Q
        elif np.isscalar(Q):
            Q = np.eye(self.dim_x)*Q
        if B is not None and u is not None: #dim_x*1
            self.x = np.dot(F,self.x)+np.dot(B,u) #x'=FX+Bu
        else:
            self.x = np.dot(F,self.x)
        self.P = np.linalg.multi_dot((F,self.P,F.T))+Q
        #save memroy
        self.x_prior = self.x.copy()
        self.P_prior = self.P.copy()
    def freeze(self):
        #it shoudle be noted that dict can be changed when update,must copy without sharing the same address
        self.attr_saved = deepcopy(self.__dict__)
    def unfreeze(self):
        '''
        Measurement-assisted Pseudo Trace Generation （MPG）
        According to [xc, yc, w, h] disappearing from time t to appearing at time t+T, a pseudo trajectory is
         generated by linear interpolation to implicitly update KF.
        '''
        #attr_save saves the last predict states
        if self.attr_saved is not None:
            new_history = deepcopy(self.history_obs)
            self.__dict__ = self.attr_saved #attr update
            self.history_obs = self.history_obs[:-1]#attr_save is updated and occur from lost time
            occur = [int(d is None) for d in new_history]
            indices = np.where(np.array(occur)==0)[0] #measurement is not None
            index1 = indices[-2]
            index2 = indices[-1]
            box1 = self.last_obs
            x1,y1,w1,h1 = box1
            box2 = new_history[index2]
            x2,y2,w2,h2 = box2
            time_gap = index2-index1
            dx = (x2-x1)/time_gap
            dy = (y2-y1)/time_gap
            dw = (w2-w1)/time_gap
            dh = (h2-h1)/time_gap
            for i in range(index2-index1):
                x = x1+(i+1)*dx
                y = y1+(i+1)*dy
                w = w1+(i+1)*dw
                h = h1+(i+1)*dh
                new_box = np.array([x,y,w,h]).reshape((4,1))
                self.update(new_box)
                if not i==(index2-index1-1):
                    self.predict()
    def project(self,mean,covariance):
        '''
        mapping state distribution into measurement domain
        Args:
            mean: np.array(dimx,1)
            covariance: np.array(dimx,dimx)

        Returns: (dimz,1),(dimz,dimz)

        '''
        mean = np.dot(self.H,mean)
        covariance = np.linalg.multi_dot((self.H,covariance,self.H.T))
        return mean,covariance+self.R

    def update(self,z,R=None,H=None):
        '''
        Pass a new measurement z for each kf. Although z is None, we update it with
        post is set to prior and z is set to None
        Args:
            z: (dimz,1)-->[x,y,w,h]
            R: observed noise (dimz,dimz)
            H: measurement function (dimz,dimx)
        '''
        self._log_likehood = None
        self._likelihood = None
        self._mahalanobis = None
        self.history_obs.append(z)

        if z is None:
            if self.observed:
                '''
                When time t is lost, attr_saved retains the updated parameters after the prediction, 
                and the observed parameter is True to generate pseudo-trajectory.
                '''
                self.last_obs = self.history_obs[-2]
                self.freeze()
            self.observed = False
            self.z = np.array([[None]*self.dim_z]).T
            self.x_post = self.x.copy()
            self.P_post = self.P.copy()
            self.y = np.zeros((self.dim_z,1))
            return  #force stop
        #todo: frozen MPG
        if not self.observed:
            self.unfreeze()
        self.observed = True

        if R is None:
            R = self.R
        elif np.isscalar(R):
            R = np.eye(self.dim_z)*R
        if H is None:
            '''
            reshape_z converts z(dim_z,) to the same number of dimensions as x
            '''
            z = reshape_z(z,self.dim_z,self.x.ndim)
            H = self.H
        #todo:when tracklet update up-to-date R is fed
        # self.y = z - np.dot(H, self.x)#(dimz,1)
        # PHT = np.dot(self.P, H.T)#(dimx,dimz)
        #todo:It is better to use non-dynamic when calculating system covariance
        # self.S = np.dot(H, PHT) + self.R#(dimz,dimz)#
        # self.SI = np.linalg.inv(self.S)#(dimz,dimz)
        # self.K = np.dot(PHT,self.SI)#(dimx,dimz)
        # self.x = self.x+np.dot(self.K,self.y)#(dimx,1)
        # I_KH = self._I - np.dot(self.K, H)#(dimx,dimx)
        # self.P = np.linalg.multi_dot((I_KH,self.P,I_KH.T))+np.linalg.multi_dot((self.K,R,self.K.T))
        #TODO: Differences of follows code-->no different

        pro_x,pro_P = self.project(self.x,self.P)
        self.S = pro_P.copy()
        self.y = z-pro_x
        '''
        The inv process is accelerated by solving AX = B
        '''
        chol_factor,lower = scipy.linalg.cho_factor(
            self.S,lower=True,check_finite=False
        )
        self.K = scipy.linalg.cho_solve(
            (chol_factor,lower),np.dot(self.P,H.T).T
        ,check_finite=False).T #(dimx,dimz)
        self.x += np.dot(self.K,self.y)
        '''
        P = (I-KH)P(I-KH)+KRK' is more stable
        '''
        I_KH = self._I-np.dot(self.K,H)
        self.P = np.linalg.multi_dot((I_KH,self.P,I_KH.T))+np.linalg.multi_dot((self.K,R,self.K.T))

        #save mesurement
        self.z = deepcopy(z)
        self.x_post = self.x.copy()
        self.P_post = self.P.copy()

    #todo:For camera motion compensation (CMC)
    def apply_affine_correction(self,m,t):
        big_m = np.kron(np.eye(4,dtype=float),m) #Kronecker product-->(8x8)
        self.x = big_m@self.x
        self.x[:2] += t
        self.P = np.linalg.multi_dot((big_m,self.P,big_m.T))

        #when measurement lost, we also need to update the frozen state for MPG
        if not self.observed and self.attr_saved is not None:
            self.attr_saved['x'] = big_m @ self.attr_saved['x']
            self.attr_saved['x'][:2] += t
            self.attr_saved["P"] = np.linalg.multi_dot((big_m,self.attr_saved["P"],big_m.T))
            self.attr_saved['last_obs'][:2] = m@self.attr_saved['last_obs'][:2]+t
            self.attr_saved['last_obs'][2:] = m@self.attr_saved['last_obs'][2:]

    def gating_distance(self,z,metric='maha'):
        '''
        Mahalanobis distance calculation for a single measurement
        '''
        # if R is None:
        #     R = self.R
        # elif np.isscalar(R):
        #     R = np.eye(self.dim_z)*R
        pro_x,pro_P = self.project(self.x,self.P)
        d = z-pro_x#(4,1)
        if metric=='gaussian':
            return float(np.sum(d*d,axis=0))
        elif metric=='maha':
            # y = z-self.H@self.x
            # md = float(np.linalg.multi_dot(y.T,self.SI,y))
            cholesky_factor = np.linalg.cholesky(pro_P)
            z = scipy.linalg.solve_triangular(
                cholesky_factor,d,lower=True,check_finite=False,
                overwrite_b = True
            )
            squared_maha = float(np.sum(z*z,axis=0))
            return squared_maha
        else:
            raise ValueError("invalid distance motion metric")



    @property
    def log_likelihood(self):
        if self._log_likehood is None:
            self._log_likehood = logpdf(x=self.y,cov=self.S)
        return self._log_likehood

    @property
    def likelihood(self):
        if self._likelihood is None:
            self._likelihood = np.exp(self.log_likelihood)
            if self._likelihood==0:
                self._likelihood = sys.float_info.min
        return self._likelihood


    def __repr__(self):
        return "\n".join(
            [
                'Measurement-assist KalmanFilter',
                pretty_str('dimx',self.dim_x),
                pretty_str('dimz',self.dim_z),
                pretty_str('dimu',self.dim_u),
                pretty_str('mean',self.x),
                pretty_str('covariance',self.P),
                pretty_str('log-likelihood',self.log_likelihood),
                pretty_str('likelihood',self.likelihood),

            ]
        )






